<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Производительность фреймворков</title>
  <link href="https://fonts.googleapis.com/css?family=Nunito&display=swap" rel="stylesheet">
  <style type="text/css">
    body {
      padding: 2% 5%;
      margin: 1%;
      font-family: 'Nunito', sans-serif;
      text-align: justify;
    }

    h1 {
      margin-bottom: 2%;
    }

    h2 {
      padding: 0 2%;
    }

    h1, h2, p {
      hyphens: auto;

      -moz-hyphens: auto;
      -webkit-hyphens: auto;
      -ms-hyphens: auto;
    }

    p {
      padding: 0 5%;
    }
    ul {
      padding: 0 7%;
    }

    ol {
      padding: 0 7%;
    }
  </style>
</head>

<body>
  <h1>Сравнение производительности фреймворков на платформе Node.js</h1>
  <h2>Актуальность</h2>
  <p>
    Архитектура REST (Representational State Transfer) API (Application Programming Interface) большое количество лет
    является востребованным шаблоном проектирования и в настоящее время представляет собой неотъемлемую часть подхода к
    формированию серверной части одностраничных и мобильных приложений, а также микросервисов.
    Node.js, приемущества которой будут рассмотрены далее, является целесообразным инструментом для разработки REST
    систем, однако существует узкоспециальная проблема по созданию приложений на данной платфоре – это выбор фреймворка.
  </p>
  <h2>Цели</h2>
  <p> Основными целями являются составление градации эффективности фреймворков, а также определение рекомендаций по их
    использованию. </p>
  <p> Для достижения поставленных целей требуется выполнить следующие этапы работы: </p>
  <ul>
    <li> определить типы фреймворков; </li>
    <li>одобрать модель приложения и определить минимальный набор модулей; </li>
    <li>выбрать оптимальные критерии производительности;</li>
    <li>провести нагрузочное тестирование;</li>
  </ul>
  <h2>Конкурентные преимущества Node </h2>
  <p>Построение RESTful API может производиться с помощью различных языков и платформ, несмотря на это, внедрение
    Node.js
    является распространенным способом для решения данной задачи ввиду некоторых особенностей платформы, а именно:</p>
  <ul>
    <li> асинхронная обработка запросов на основе формирования событий: каждое подключение вызывает событие, которое
      поступает в очередь на обработку или так называемый event loop, и в тот момент, когда Node.js имеет время на
      выполнение запроса, происходит обработка данного запроса;</li>
    <li> так же желательно обрабатывать весь доступ к файлам и базам данных через асинхронные методы, что позволяет ядру
      Node.js самостоятельно производить чтение и запись, тем самым избегая взаимных блокировок; </li>
    <li> необходимо отметить и то, что функции модуля HTTP, на котором строятся все фреймворки и библиотеки, является
      приоритетным в обработке, поэтому платформа позволяет строить отказоустойчивые веб-системы.</li>
  </ul>
  <h2>Классификация</h2>
  <p>Первоначально требуется определить типы фреймворков, так как особенности структуры фреймворка влияют на многие
    параметры будущего приложения. Для исследования предпочтительными являются фреймворки, которые имеют необходимый
    функционал для формирования REST приложения.</p>
  <ul>
    <li>
      Библиотека HTTP-сервера – комплект функций, которые предоставляют возможности по построению приложения на их
      основе;
    </li>
    <li>API-фреймворк – набор функций, который является каркасом для разработки приложения REST-API;</li>
    <li>Фреймворк HTTP-сервера – расширение библиотеки-HTTP, которое формирует дополнительный слой абстракции, а также
      предоставляет скелет сервера;</li>
    <li>Веб-фреймворк MVC – фреймворк, который используется для создания приложений, основываясь на паттерне MVC
      (Модель-Представление-Контроллер;
    </li>
    <li>
      Полностековый фреймворк – данный тип является оберткой над более простыми фреймворками, которая позволяет
      упростить разработку одностраничного приложения с помощью клиентского фреймворка (React/Vue).
    </li>
  </ul>
  <p>
    На первом этапе анализа были изучены исследования команды разработчикова Fastify, а также компании TechPower на
    тему
    определения производительности фреймворков на основе Hello World приложений. Согласно данным исследованиям были
    определены наиболее эффективные фреймворки каждого типа, которые будут
    представлены далее. Также выбор подкреплен оценками GitHub, что обуславливает популярность взятых фреймворков. 
  </p>
  <h2>Библиотека HTTP-сервера</h2>
  <p>Данные фреймворки предназначены для создания любых веб-приложений, однако имеют ограниченный функционал.</p>
  <p>Express – наиболее известная библиотека на платформе Node.js; на его основе строятся как простые API, так и
    крупные
    приложения; также зачастую является фундаментом для других фреймворков, например Next/Nuxt, Nest;</p>
  <p>Restify – библиотека для организации правильных RESTful сервисов, синтаксис и построение которого намеренно схожи
    с
    Express.</p>
  <h2>API-фреймворк </h2>
  <p>Данные фреймворки предназначены для создания простых приложений и API приложений.</p>
  <p>Loopback – крупный проект, который на данный момент перешёл к 4 итерации, имеющую собственный движок,
    автоматическую
    генерацию API, нативную поддержку Typescript;</p>
  <p>Fastify – позиционируется как самый быстрый фреймворк для разработки приложений на Node.js.</p>
  <h2>Фреймворк HTTP-сервера </h2>
  <p>Данные фреймворки предназначены для создания крупных приложений и API приложений.</p>
  <p>Koa – фреймворк с намеренно минимальным набором функций, модульным построением и новой в отличии от Express
    передачей
    запроса через обработчики;</p>
  <p>Hapi – фреймворк с встроенным функционалом, позволяющим строить любые приложения, расширяемый собственными
    плагинами.
  </p>
  <h2>Веб-фреймворк MVC </h2>
  <p>Данные фреймворки предназначены для создания крупных приложений на основе паттерна MVC.</p>
  <p>Sails – популярный MVC фреймворк, подражающий такому фреймворку как Ruby on Rails, но нацеленный на создание API;
  </p>
  <p>Nest – фреймворк, построенный на Typescript, комбинирующий ООП и функциональную структуру приложений и являющийся
    абстракцией над Express или Fastify.</p>
  <h2>Полностековый фреймворк на базе другого фреймворка</h2>
  <p>Next и Nuxt являются надстройками над Express для упрощения работы с SPA, поэтому их использование для
    организации
    API не оправдано, и в исследовании они не задействовались.</p>
  <h2>Структура приложения </h2>
  <p>Для того, чтобы унифицировать задачу определения производительности, в данном исследовании предлагается ввести
    общий
    шаблон приложения, которое будет реализовано на разных фреймворках, но предоставляющее единый функционал.</p>
  <p>Приложения REST API в большинстве случаев используются для предоставления удаленных ресурсов клиентам. В данном
    случае определяется система для выдачи статических файлов по параметрам запроса. </p>
  <p>Требуется учитывать и состояние, в котором находится приложение. Различают типы приложений с состоянием, где
    такого
    рода данные хранятся в запущенном приложении, и без состояния, где такая информация сохраняется в специальные
    хранилища, например Redis. </p>
  <p>Фреймворки на Node.js имеют схожую структуру, поэтому может быть заранее определен состав приложения:</p>
  <ul>
    <li>Logger – обработчик, сохраняющий информацию о запросах;</li>
    <li>Bodyparser – функция, выделяющая тело запроса, которое требуется для операций Create и Update;</li>
    <li>Статика – обработчик, выдающий статические файлы из публичной директории;</li>
    <li>Обработка хранения состояния приложения;</li>
    <li>Роутер – обрабатывает запрашиваемые пути для распределения по дальнейшим функциям; </li>
    <li>Контроллеры – обработчики действий, которые необходимо совершать с запросом;</li>
    <li>Обработчик ошибок, которые были сгенерированы по пути обработки запроса, к примеру 404 Bad Request или 500
      Internal Server Error.</li>
  </ul>
  <h2>Создание сервера</h2>
  <p>На нескольких последующих слайдах схематично представлено шаблонное API приложение в виде фрагментов кода
    фреймворка
    Express, однако иные исследуемые фреймворки имеют схожие синтаксис и подход к организации обработки запросов. </p>
  <p>В большинстве фреймворков обработка запроса происходит как переход через несколько этапов конвейера, при этом
    каждый
    этап имеет доступ к полученному запросу и предполагаемому ответу, которые он может модифицировать согласной
    собственной программе. Каждый такой этап называется промежуточным обработчиком от англ. middleware.</p>
  <p>Для создания сервера вызывается собственный модуль платформы Node.js http, в который, как промежуточный
    обработчик,
    встраивается проектируемое приложение. Также можно представить создание сервера.</p>
  <h2>Роутер и контроллер</h2>
  <p>Основные этапы обработки запроса - роутинг и контроллер. При этом роутер так же
    представляет собой слой с промежуточными обработчиками, если это будет необходимо. Для создания сервера вызывается
    собственный модуль платформы Node.js http, в который, как промежуточный обработчик, встраивается проектируемое
    приложение. Также можно представить создание сервера</p>
  <h2>Обработка ошибок</h2>
  <p>В общем случае запрос должен быть обработан и отправлен при попадании в контроллер, который обрабатывает
    определенный
    маршрут. Однако в случае отсутствия указанного маршрута, и не попав в соответствие с существующими маршрутами
    приложения, запрос отправляется в последний обработчик, который формирует статус 404, отсутствие существующего
    пути.
    Более того, при появлении нештатных ситуаций, промежуточные обработчики могут формировать ошибки, которые будут
    передаваться через последующие обработчики, минуя их штатное назначение. Для того, чтобы отлавливать такие ошибки
    создается специальный обработчик в конце всего приложения, который будет информировать пользователя о появлении
    ошибки.</p>
  <h2>Стенд для тестирования </h2>
  <p>Тестирование производилось на оборудовании, характеристики которого представлены на слайде:</p>
  <ul>
    <li>процессор: Intel Core i5-4200U CPU @ 1.60GHz 2.30GHz;</li>
    <li>операционная система: Ubuntu 16.04 x64t;</li>
    <li>размер оперативной памяти: 8 GB RAM;</li>
    <li>размер памяти: 120 GB SSD;</li>
    <li>Node 12.13.1</li>
  </ul>
  <h2>План тестирования</h2>
  <p>Производительность приложения характеризуется большим количеством параметров приложения, в том числе
    эффективностью
    использованных технологий, правильностью подхода к организации архитектуры, сопротивляемостью внешним нагрузкам и
    так
    далее. В связи с этим каждое приложение должно быть подвергнуто нагрузочному тестированию.</p>
  <p>Тестирование проводилось с помощью имитации конкурирующих соединений пользователей в количестве 100 и 300. </p>
  <p>Для теста приложений в исследовании были выбраны следующие критерии производительности:</p>
  <ul>
    <li>Запросы в секунду </li>
    <li>Среднее время отклика (мс) </li>
  </ul>
  <p>Данные критерии были выбраны в связи с тем, что они являются наиболее показательными параметрами системы, если
    сервер
    будет представлен в виде черного ящика</p>
  <p>Для проведения данного нагрузочного тестирования использовался инструмент autocannon - утилита для нагрузочного
    тестирования, написанная для Node.js. </p>

  <h2>Результаты </h2>
  <p>
    Были сделаны выводы, о том что наиболее быстрым фреймворком является Fastify, и приложения на его основе опережают
    конкурентов минимум в два раза. Однако несмотря на меньшую производительность, некоторые из оставшихся фреймворков
    обладают более удобным подходом к разработке. Koa позволяет наиболее гибким способом обрабатывать ошибки.
    Фреймворки
    Loopback и Nest предоставляют богатый встроенный функционал для быстрого построения API систем, так как обладают
    собственной консольной утилитой формирования проектов.
  </p>
  <p>
    Исходя из данных, полученных в ходе создания приложений и их тестирования, можно сформулировать следующие
    рекомендации по использованию фреймворков и библиотек:
  </p>
  <ul>
    <li>На основе Restify предлагается формировать временные локальные сервера тестирования для предоставления файлов
      одностраничных приложений.</li>
    <li>В силу полученных в результате исследования данных о быстродействии библиотек для построения API рекомендуется
      использовать библиотеку Fastify для динамического развертывания быстрых endpoint-ов, обслуживающих потребности
      клиентов в вычислениях, не зависящих от файловой системы и внешних ресурсов.</li>
    <li>Также из результатов исследования следует, что для организации простых приложений, который предоставляют
      статические
      файлы и имеют упрощенную систему контроллеров, эффективным методом создания системы будет использование
      библиотеки
      Express или фреймворка Koa. Следует заметить, что более быстрым решением является Koa</li>
    <li>Для создания крупных систем, наиболее целесообразным выбором будут фреймворки Nest, Hapi и Sails, которые
      имеют
      достаточный функционал , необходимый для создания приложений сложного уровня, то есть имеющих нетривиальную
      конфигурацию маршрутов, авторизацию, поддержку формирования клиентских интерфейсов. Более того, данные
      фреймворки
      диктуют структуру проектов, что позволяет сохранять поддерживаемость крупных проектов. Однако необходимо
      отметить,
      что
      наиболее производительное решение будет базироваться на Nest.</li>
  </ul>
  <h2>Выводы</h2>
  <p>В данном исследовании были отобраны типы фреймворков для разбиения на классы по назначению использования. В связи
    с
    тем, что проведение нагрузочного тестирования фреймворков абстрактно, то есть без существующего приложения, крайне
    затруднительно, был введен прототип REST системы, который реализовывался на всех фреймворках. Далее созданные
    системы
    были подвергнуты проверке на производительность с целью выявления наиболее эффективного фреймворка. </p>
  <p>Проведенное исследование может быть использовано в качестве фундамента для проведения дальнейших измерений либо
    для
    первоначального выбора фреймворка по производительности.</p>
  <h2 id="refs">Источники</h2>
  <ol>
    <li>Powers S. Learing Node: Moving to the Server Side. – second edition. – O’Reilly: O’Reilly Media, Inc., 2016. –
      304 p.</li>
    <li>Young A., Meck B., Cantelon M. Node.js in Action. – second edition. – Manning Publications Co., 2017. – 432 p.
    </li>
    <li>StrongLoop Node.js Framework Comparison [Электронный ресурс]. Режим доступа:
      <a href="https://loopback.io/resources/#compare">https://loopback.io/resources/#compare</a> (дата обращения:
      02.10.2019)</li>
    <li> Официальный сайт Node.js [Электронный ресурс]. Режим доступа: <a
        href="https://nodejs.org/en/about">https://nodejs.org/en/about</a> (дата обращения:
      05.10.2019)</li>
    <li>Brown E. Web Development with Express and Node. – O’Reilly: O’Reilly Media, Inc., 2016. – 336 p.</li>
  </ol>

</body>

</html>